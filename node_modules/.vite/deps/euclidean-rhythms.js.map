{
  "version": 3,
  "sources": ["../../euclidean-rhythms/dist/index.js"],
  "sourcesContent": ["\"use strict\";\n\n/**\n   *  Returns the calculated pattern of equally distributed pulses in total steps\n   *  based on the euclidean rhythms algorithm described by Godfried Toussaint\n   *\n   *  @method  getPattern\n   *  @param {Number} pulses Number of pulses in the pattern\n   *  @param {Number} steps  Number of steps in the pattern (pattern length)\n   */\nvar getPattern = function getPattern(pulses, steps) {\n  if (pulses < 0 || steps < 0 || steps < pulses) {\n    return [];\n  }\n\n  // Create the two arrays\n  var first = new Array(pulses).fill([1]);\n  var second = new Array(steps - pulses).fill([0]);\n\n  var firstLength = first.length;\n  var minLength = Math.min(firstLength, second.length);\n\n  var loopThreshold = 0;\n  // Loop until at least one array has length gt 2 (1 for first loop)\n  while (minLength > loopThreshold) {\n    // Allow only loopThreshold to be zero on the first loop\n    if (loopThreshold === 0) {\n      loopThreshold = 1;\n    }\n\n    // For the minimum array loop and concat\n    for (var x = 0; x < minLength; x++) {\n      first[x] = Array.prototype.concat.call(first[x], second[x]);\n    }\n\n    // if the second was the bigger array, slice the remaining elements/arrays and update\n    if (minLength === firstLength) {\n      second = Array.prototype.slice.call(second, minLength);\n    }\n    // Otherwise update the second (smallest array) with the remainders of the first\n    // and update the first array to include onlt the extended sub-arrays\n    else {\n        second = Array.prototype.slice.call(first, minLength);\n        first = Array.prototype.slice.call(first, 0, minLength);\n      }\n    firstLength = first.length;\n    minLength = Math.min(firstLength, second.length);\n  }\n\n  // Build the final array\n  var pattern = [];\n  first.forEach(function (f) {\n    pattern = Array.prototype.concat.call(pattern, f);\n  });\n  second.forEach(function (s) {\n    pattern = Array.prototype.concat.call(pattern, s);\n  });\n\n  return pattern;\n};\n\nmodule.exports = {\n  getPattern: getPattern\n};"],
  "mappings": ";;;;;AAAA;AAAA;AAUA,QAAI,aAAa,SAASA,YAAW,QAAQ,OAAO;AAClD,UAAI,SAAS,KAAK,QAAQ,KAAK,QAAQ,QAAQ;AAC7C,eAAO,CAAC;AAAA,MACV;AAGA,UAAI,QAAQ,IAAI,MAAM,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;AACtC,UAAI,SAAS,IAAI,MAAM,QAAQ,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;AAE/C,UAAI,cAAc,MAAM;AACxB,UAAI,YAAY,KAAK,IAAI,aAAa,OAAO,MAAM;AAEnD,UAAI,gBAAgB;AAEpB,aAAO,YAAY,eAAe;AAEhC,YAAI,kBAAkB,GAAG;AACvB,0BAAgB;AAAA,QAClB;AAGA,iBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAClC,gBAAM,CAAC,IAAI,MAAM,UAAU,OAAO,KAAK,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,QAC5D;AAGA,YAAI,cAAc,aAAa;AAC7B,mBAAS,MAAM,UAAU,MAAM,KAAK,QAAQ,SAAS;AAAA,QACvD,OAGK;AACD,mBAAS,MAAM,UAAU,MAAM,KAAK,OAAO,SAAS;AACpD,kBAAQ,MAAM,UAAU,MAAM,KAAK,OAAO,GAAG,SAAS;AAAA,QACxD;AACF,sBAAc,MAAM;AACpB,oBAAY,KAAK,IAAI,aAAa,OAAO,MAAM;AAAA,MACjD;AAGA,UAAI,UAAU,CAAC;AACf,YAAM,QAAQ,SAAU,GAAG;AACzB,kBAAU,MAAM,UAAU,OAAO,KAAK,SAAS,CAAC;AAAA,MAClD,CAAC;AACD,aAAO,QAAQ,SAAU,GAAG;AAC1B,kBAAU,MAAM,UAAU,OAAO,KAAK,SAAS,CAAC;AAAA,MAClD,CAAC;AAED,aAAO;AAAA,IACT;AAEA,WAAO,UAAU;AAAA,MACf;AAAA,IACF;AAAA;AAAA;",
  "names": ["getPattern"]
}
