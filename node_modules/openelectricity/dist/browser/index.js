import dayjs from 'dayjs';
import timezone from 'dayjs/plugin/timezone';
import utc from 'dayjs/plugin/utc';

/**
 * Datetime utilities for OpenElectricity
 *
 * This module provides utilities for handling dates and times in the OpenElectricity API.
 * All functions are timezone-aware and handle network-specific timezone offsets.
 */
dayjs.extend(utc);
dayjs.extend(timezone);
/**
 * Network timezone offsets in hours
 * NEM (National Electricity Market): AEST/UTC+10
 * WEM (Western Australia): AWST/UTC+8
 * AU (Australia): AEST/UTC+10
 */
const NETWORK_TIMEZONE_OFFSETS = {
    NEM: 10, // AEST
    WEM: 8, // AWST
    AU: 10, // Default to AEST
};
/**
 * Get the timezone offset in hours for a network
 *
 * @param network The network code
 * @returns Timezone offset in hours (e.g. 10 for AEST/UTC+10)
 *
 * @example
 * ```typescript
 * getNetworkTimezone("NEM") // Returns 10 (AEST/UTC+10)
 * getNetworkTimezone("WEM") // Returns 8 (AWST/UTC+8)
 * ```
 */
function getNetworkTimezone(network) {
    return NETWORK_TIMEZONE_OFFSETS[network];
}
/**
 * Get timezone offset in milliseconds for a network
 *
 * @param network The network code
 * @returns Timezone offset in milliseconds
 */
function getNetworkTimezoneOffset(network) {
    return NETWORK_TIMEZONE_OFFSETS[network] * 60 * 60 * 1000; // Convert hours to milliseconds
}
/**
 * Check if a date string is timezone aware (has timezone information)
 *
 * @param dateStr Date string to check
 * @returns true if the date string contains timezone information
 */
function isAware(dateStr) {
    if (dateStr instanceof Date) {
        return false; // JavaScript Date objects are always in local time
    }
    return dateStr.includes("Z") || /[+-]\d{2}:?\d{2}$/.test(dateStr);
}
/**
 * Make a date timezone aware by adding the network's timezone offset
 *
 * @param date Date string or Date object to make timezone aware
 * @param network Network code to get timezone from
 * @returns ISO string with timezone information
 */
function makeAware(date, network) {
    const offset = NETWORK_TIMEZONE_OFFSETS[network];
    const sign = offset >= 0 ? "+" : "-";
    const absOffset = Math.abs(offset);
    const hours = String(Math.floor(absOffset)).padStart(2, "0");
    const minutes = String((absOffset % 1) * 60).padStart(2, "0");
    const d = dayjs(date);
    return d.format(`YYYY-MM-DDTHH:mm:ss${sign}${hours}:${minutes}`);
}
/**
 * Strip timezone information from a date string
 *
 * @param dateStr Date string to strip timezone from
 * @returns Date string without timezone information
 */
function stripTimezone(dateStr) {
    // Match everything up to but not including Z, + or - followed by timezone offset
    const match = dateStr.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}/);
    return match ? match[0] : dateStr;
}
/**
 * Get the last complete 5-minute interval for a network
 *
 * @param network Network code to get timezone from
 * @returns ISO string of the last complete 5-minute interval in network time
 */
function getLastCompleteInterval(network) {
    const offset = NETWORK_TIMEZONE_OFFSETS[network];
    // Get current time in UTC
    const utcNow = dayjs.utc();
    // Convert to network timezone
    const networkTime = utcNow.utcOffset(offset * 60); // offset in minutes
    // Round down to nearest 5 minutes and subtract 5 minutes to get last complete interval
    const minutes = networkTime.minute();
    const lastInterval = networkTime
        .minute(Math.floor(minutes / 5) * 5)
        .second(0)
        .millisecond(0)
        .subtract(5, "minute");
    // Format without timezone information as required by API
    return lastInterval.format("YYYY-MM-DDTHH:mm:ss");
}
/**
 * Creates a date from an ISO string with timezone information.
 *
 * The JavaScript Date constructor correctly handles ISO 8601 strings with timezone
 * offsets (e.g., "2024-04-07T00:00:00+10:00"), so no manual adjustment is needed.
 *
 * @param isoString ISO 8601 date string with timezone offset
 * @returns Date object representing the correct point in time
 */
function createNetworkDate(isoString) {
    // The Date constructor already handles timezone-aware ISO strings correctly
    return new Date(isoString);
}

/**
 * DataTable implementation for OpenElectricity API
 * Provides a pandas/polars-like interface for time series data
 */
class DataTable {
    constructor(rows, groupings, metrics) {
        this.cache = {};
        this.rows = rows;
        this.groupings = groupings;
        this.metrics = metrics;
        this.rowsMap = new Map();
        // Create initial indexes
        this.createRowMap();
        this.createColumnIndexes();
    }
    /**
     * Create a DataTable from NetworkTimeSeries responses
     */
    static fromNetworkTimeSeries(data) {
        const rows = [];
        const groupings = data[0].groupings || [];
        const metrics = new Map();
        const table = new DataTable(rows, groupings, metrics);
        // Create a map of all metrics and their units
        data.forEach((series) => {
            metrics.set(series.metric, series.unit);
        });
        // Process each time series into rows
        data.forEach((series) => {
            series.results.forEach((result) => {
                result.data.forEach(([timestamp, value]) => {
                    const date = createNetworkDate(timestamp);
                    const dateKey = date.toISOString();
                    // Create a unique key for the row
                    const rowKey = [
                        dateKey,
                        ...Object.entries(result.columns).map(([k, v]) => `${k}:${v}`),
                    ].join("_");
                    // Find or create row using rowsMap
                    let row = table.getRowByKey(rowKey);
                    if (!row) {
                        row = {
                            interval: date,
                            ...result.columns,
                            [series.metric]: value,
                        };
                    }
                    else {
                        row[series.metric] = value;
                    }
                    table.setRowByKey(rowKey, row);
                });
            });
        });
        // Sort rows by interval
        table.rows.sort((a, b) => a.interval.getTime() - b.interval.getTime());
        return table;
    }
    createRowMap() {
        this.rowsMap = new Map(this.rows.map((row) => [this.createRowKey(row), row]));
    }
    createRowKey(row) {
        const parts = [row.interval.toISOString()];
        for (const grouping of this.groupings) {
            parts.push(`${grouping}:${row[grouping]}`);
        }
        return parts.join("_");
    }
    createColumnIndexes() {
        this.cache.columnIndexes = new Map();
        // Create indexes for grouping columns
        for (const column of this.groupings) {
            const columnIndex = new Map();
            for (const row of this.rows) {
                const value = row[column];
                // Skip null values in index
                if (value === null || value instanceof Date)
                    continue;
                if (!columnIndex.has(value)) {
                    columnIndex.set(value, []);
                }
                const rows = columnIndex.get(value);
                if (rows) {
                    rows.push(row);
                }
            }
            this.cache.columnIndexes.set(column, columnIndex);
        }
    }
    /**
     * Get a row by its unique key
     * Used internally for efficient row lookups
     */
    getRowByKey(key) {
        return this.rowsMap.get(key);
    }
    /**
     * Update or add a row by its key
     * Used internally for merging data
     */
    setRowByKey(key, row) {
        this.rowsMap.set(key, row);
        if (!this.rows.includes(row)) {
            this.rows.push(row);
        }
    }
    /**
     * Get all rows in the table
     */
    getRows() {
        return this.rows;
    }
    /**
     * Get available grouping columns
     */
    getGroupings() {
        return this.groupings;
    }
    /**
     * Get the metrics and their units
     */
    getMetrics() {
        return this.metrics;
    }
    /**
     * Get the latest timestamp in the data
     */
    getLatestTimestamp() {
        if (!this.cache.latestTimestamp) {
            this.cache.latestTimestamp = Math.max(...this.rows.map((r) => r.interval.getTime()));
        }
        return this.cache.latestTimestamp;
    }
    /**
     * Filter rows based on a condition
     */
    filter(condition) {
        // Check if we can use index for simple equality conditions
        const indexedFilter = this.tryIndexFilter(condition);
        if (indexedFilter) {
            return indexedFilter;
        }
        // Fall back to regular filter for complex conditions
        const filteredRows = this.rows.filter(condition);
        return new DataTable(filteredRows, this.groupings, this.metrics);
    }
    tryIndexFilter(condition) {
        // Try to find matching rows in our column indexes
        for (const [column, columnIndex] of this.cache.columnIndexes || []) {
            // Test the first row to see if this is a simple equality check on this column
            if (this.rows.length === 0)
                return null;
            const testRow = { ...this.rows[0] };
            // Try each possible value from the index
            for (const [value, rows] of columnIndex) {
                // Test if this is an equality check for this value
                testRow[column] = value;
                const otherValues = { ...testRow };
                otherValues[column] =
                    value === true ? false : value === false ? true : value === 0 ? 1 : 0;
                if (condition(testRow) && !condition(otherValues)) {
                    return new DataTable([...rows], this.groupings, this.metrics);
                }
            }
        }
        return null;
    }
    /**
     * Select specific columns
     */
    select(columns) {
        const newRows = this.rows.map((row) => {
            const newRow = { interval: row.interval };
            columns.forEach((col) => {
                if (col in row) {
                    newRow[col] = row[col];
                }
            });
            return newRow;
        });
        // Filter metrics to only include those in selected columns
        const newMetrics = new Map();
        this.metrics.forEach((unit, metric) => {
            if (columns.includes(metric)) {
                newMetrics.set(metric, unit);
            }
        });
        return new DataTable(newRows, this.groupings.filter((g) => columns.includes(g)), newMetrics);
    }
    /**
     * Group by specified columns and aggregate values
     */
    groupBy(columns, aggregation = "sum") {
        const cacheKey = `${columns.join("_")}_${aggregation}`;
        const cachedGroups = this.cache.groupedRows?.get(cacheKey);
        if (cachedGroups) {
            return new DataTable(Array.from(cachedGroups.values()).flat(), columns, this.metrics);
        }
        const groups = new Map();
        const groupKeyMap = new Map();
        // Single pass grouping and aggregation
        for (const row of this.rows) {
            const groupKey = columns.map((col) => `${col}:${row[col]}`).join("_");
            if (!groups.has(groupKey)) {
                groups.set(groupKey, []);
                groupKeyMap.set(groupKey, columns.reduce((acc, col) => {
                    acc[col] = row[col];
                    return acc;
                }, {}));
            }
            const groupRows = groups.get(groupKey);
            if (groupRows) {
                groupRows.push(row);
            }
        }
        // Efficient aggregation using pre-allocated arrays
        const newRows = [];
        const metricNames = Array.from(this.metrics.keys());
        for (const [groupKey, groupRows] of groups) {
            const groupValues = groupKeyMap.get(groupKey);
            if (!groupValues)
                continue;
            const newRow = {
                interval: groupRows[0].interval,
                ...groupValues,
            };
            // Pre-allocate arrays for metric values
            const metricArrays = new Map();
            metricNames.forEach((metric) => {
                metricArrays.set(metric, new Array(groupRows.length));
            });
            // Single pass to collect all metric values
            for (let i = 0; i < groupRows.length; i++) {
                const row = groupRows[i];
                metricNames.forEach((metric) => {
                    const value = row[metric];
                    const metricArray = metricArrays.get(metric);
                    if (value !== null && !Number.isNaN(value) && metricArray) {
                        metricArray[i] = value;
                    }
                });
            }
            // Calculate aggregations
            metricNames.forEach((metric) => {
                const metricArray = metricArrays.get(metric);
                if (metricArray) {
                    const values = metricArray.filter((v) => v !== undefined);
                    if (values.length > 0) {
                        const sum = values.reduce((a, b) => a + b, 0);
                        newRow[metric] = aggregation === "sum" ? sum : sum / values.length;
                    }
                    else {
                        newRow[metric] = null;
                    }
                }
            });
            newRows.push(newRow);
        }
        // Cache the results
        if (!this.cache.groupedRows) {
            this.cache.groupedRows = new Map();
        }
        this.cache.groupedRows.set(cacheKey, groups);
        return new DataTable(newRows, columns, this.metrics);
    }
    /**
     * Sort rows by specified columns
     */
    sortBy(columns, ascending = true) {
        const cacheKey = `${columns.join("_")}_${ascending}`;
        const cachedRows = this.cache.sortedRows?.get(cacheKey);
        if (cachedRows) {
            return new DataTable([...cachedRows], this.groupings, this.metrics);
        }
        const sortedRows = [...this.rows].sort((a, b) => {
            for (const col of columns) {
                const aVal = a[col];
                const bVal = b[col];
                if (aVal === null && bVal === null)
                    continue;
                if (aVal === null)
                    return ascending ? -1 : 1;
                if (bVal === null)
                    return ascending ? 1 : -1;
                if (aVal < bVal)
                    return ascending ? -1 : 1;
                if (aVal > bVal)
                    return ascending ? 1 : -1;
            }
            return 0;
        });
        // Cache the results
        if (!this.cache.sortedRows) {
            this.cache.sortedRows = new Map();
        }
        this.cache.sortedRows.set(cacheKey, sortedRows);
        return new DataTable(sortedRows, this.groupings, this.metrics);
    }
    /**
     * Convert to console-friendly format
     */
    toConsole() {
        return this.rows.map((row) => {
            const { interval, ...rest } = row;
            return {
                interval: interval.toISOString(),
                ...rest,
            };
        });
    }
    /**
     * Generate summary statistics for numeric columns
     */
    describe() {
        const result = {};
        const numericColumns = Object.keys(this.rows[0] || {}).filter((key) => typeof this.rows[0][key] === "number");
        // Pre-allocate arrays for each column
        const columnArrays = new Map();
        numericColumns.forEach((column) => {
            columnArrays.set(column, []);
        });
        // Single pass to collect all values
        for (const row of this.rows) {
            numericColumns.forEach((column) => {
                const value = row[column];
                const columnArray = columnArrays.get(column);
                if (typeof value === "number" && !Number.isNaN(value) && columnArray) {
                    columnArray.push(value);
                }
            });
        }
        // Calculate statistics for each column
        numericColumns.forEach((column) => {
            const values = columnArrays.get(column);
            if (!values || values.length === 0)
                return;
            values.sort((a, b) => a - b);
            const count = values.length;
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = sum / count;
            // Calculate variance in single pass
            let variance = 0;
            for (const value of values) {
                variance += (value - mean) ** 2;
            }
            variance /= count;
            result[column] = {
                count,
                mean,
                std: Math.sqrt(variance),
                min: values[0],
                q25: values[Math.floor(count * 0.25)],
                median: values[Math.floor(count * 0.5)],
                q75: values[Math.floor(count * 0.75)],
                max: values[values.length - 1],
            };
        });
        return result;
    }
}
/**
 * Create a DataTable from NetworkTimeSeries responses
 */
function createDataTable(data) {
    return DataTable.fromNetworkTimeSeries(data);
}

/**
 * RecordTable implementation for OpenElectricity API
 * Provides a simple interface for navigating record-style data like facilities
 */
class RecordTable {
    constructor(records) {
        this.records = records;
        this.columnNames = records.length > 0 ? Object.keys(records[0]) : [];
    }
    /**
     * Get all records
     */
    getRecords() {
        return this.records;
    }
    /**
     * Get available column names
     */
    getColumns() {
        return this.columnNames;
    }
    /**
     * Get a subset of columns
     */
    select(columns) {
        const selectedRecords = this.records.map((record) => {
            const newRecord = {};
            columns.forEach((col) => {
                if (col in record) {
                    newRecord[col] = record[col];
                }
            });
            return newRecord;
        });
        return new RecordTable(selectedRecords);
    }
    /**
     * Filter records based on a condition
     */
    filter(condition) {
        return new RecordTable(this.records.filter(condition));
    }
    /**
     * Sort records by specified columns
     */
    sortBy(columns, ascending = true) {
        const sortedRecords = [...this.records].sort((a, b) => {
            for (const col of columns) {
                const aVal = a[col];
                const bVal = b[col];
                if (aVal === bVal)
                    continue;
                if (aVal === null)
                    return ascending ? -1 : 1;
                if (bVal === null)
                    return ascending ? 1 : -1;
                if (aVal < bVal)
                    return ascending ? -1 : 1;
                if (aVal > bVal)
                    return ascending ? 1 : -1;
            }
            return 0;
        });
        return new RecordTable(sortedRecords);
    }
    /**
     * Get unique values in a column
     */
    unique(column) {
        const values = new Set();
        this.records.forEach((record) => {
            values.add(record[column]);
        });
        return Array.from(values);
    }
    /**
     * Get a slice of records
     */
    slice(start, end) {
        return new RecordTable(this.records.slice(start, end));
    }
    /**
     * Convert to array format
     */
    toArray() {
        return [...this.records];
    }
    /**
     * Convert to JSON string with pretty formatting
     */
    toString() {
        return JSON.stringify(this.records, null, 2);
    }
}

/**
 * Utility functions for OpenElectricity client
 */
/**
 * Safely detect if we're in a development environment
 * Works in both Node.js, browser, and SSR environments
 */
const isDevelopment = (() => {
    // Check for Node.js environment
    try {
        // Check for SSR environment (Node.js but potentially missing some browser APIs)
        const isSSR = typeof process !== "undefined" &&
            typeof window === "undefined" &&
            process?.env?.NODE_ENV !== undefined;
        // If in SSR, use the NODE_ENV value
        if (isSSR) {
            return process?.env?.NODE_ENV === "development";
        }
        // Regular Node.js environment check
        if (typeof process !== "undefined" &&
            process?.env?.NODE_ENV === "development") {
            return true;
        }
        // Check for browser development environments
        if (typeof window !== "undefined" && window?.location?.hostname) {
            const hostname = window.location.hostname;
            if (hostname === "localhost" ||
                hostname === "127.0.0.1" ||
                hostname.includes("dev.") ||
                hostname.includes(".local")) {
                return true;
            }
        }
    }
    catch {
        // Ignore any errors
    }
    return false;
})();
/**
 * Debug logging function
 * Only logs in development mode
 */
function debug(message, data) {
    if (isDevelopment) {
        console.log(`[OpenElectricity] ${message}`, data ? data : "");
    }
}

/**
 * OpenElectricity API Client
 *
 * A TypeScript client for the OpenElectricity API v4.
 * Provides access to electricity network data and metrics.
 */
/// <reference lib="dom" />
class OpenElectricityError extends Error {
    constructor(message, response, statusCode, details) {
        super(message);
        this.response = response;
        this.statusCode = statusCode;
        this.details = details;
        this.name = "OpenElectricityError";
    }
}
class NoDataFound extends Error {
    constructor(message) {
        super(message);
        this.name = "NoDataFound";
    }
}
/**
 * Convert a date string to timezone naive format and warn if timezone information is present
 *
 * @param date The date string to process
 * @param paramName The name of the parameter (for warning message)
 * @returns The timezone naive date string
 */
function toTimezoneNaiveDate(date, paramName) {
    if (!date)
        return undefined;
    if (isAware(date)) {
        debug(`Warning: ${paramName} contains timezone information which will be stripped. The API requires timezone naive dates in network time.`, {
            original: date,
            stripped: stripTimezone(date),
        });
        return stripTimezone(date);
    }
    return date;
}
class OpenElectricityClient {
    // private static apiVersion: string = "v4"
    constructor(options = {}) {
        // eslint-disable-next-line no-undef
        this.apiKey = options.apiKey || process?.env?.OPENELECTRICITY_API_KEY || "";
        if (!this.apiKey) {
            throw new Error("API key is required");
        }
        // eslint-disable-next-line no-undef
        this.baseUrl =
            options.baseUrl ||
                process?.env?.OPENELECTRICITY_API_URL ||
                "https://api.openelectricity.org.au/v4";
        debug("Initializing client", { baseUrl: this.baseUrl });
    }
    async request(path, options = {}) {
        const url = `${this.baseUrl}${path}`;
        const headers = {
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
            ...options.headers,
        };
        debug("Making request", {
            url,
            method: options.method || "GET",
            headers: { ...headers, Authorization: "***" },
        });
        const startTime = Date.now();
        // eslint-disable-next-line no-undef
        const response = await fetch(url, {
            ...options,
            headers,
        });
        const duration = Date.now() - startTime;
        debug(`Request completed in ${duration}ms`, {
            status: response.status,
            statusText: response.statusText,
        });
        // Special handling for 416 (no results)
        if (response.status === 416) {
            throw new NoDataFound("No data found for the requested parameters");
        }
        // Special handling for 403 (permission denied)
        if (response.status === 403) {
            debug("Permission denied", {
                status: response.status,
                statusText: response.statusText,
            });
            throw new Error("Permission denied. Check API key or your access level");
        }
        // Try to parse JSON response, handle cases where response is not valid JSON
        let data;
        try {
            data = await response.json();
        }
        catch (jsonError) {
            // If we can't parse JSON and it's an error response, provide a meaningful error
            if (!response.ok) {
                debug("Failed to parse JSON response", {
                    status: response.status,
                    statusText: response.statusText,
                    error: jsonError,
                });
                // For 500 errors, provide a more specific message
                if (response.status === 500) {
                    throw new OpenElectricityError("Internal server error - the requested data may not be available for this date range", undefined, response.status, { parseError: "Response was not valid JSON" });
                }
                throw new OpenElectricityError(`API request failed: ${response.statusText} (unable to parse response)`, undefined, response.status, { parseError: "Response was not valid JSON" });
            }
            throw jsonError;
        }
        // Handle API error responses
        if (!response.ok) {
            debug("Request failed", {
                status: response.status,
                statusText: response.statusText,
                data,
            });
            // Parse different error response formats
            let errorMessage = `API request failed: ${response.statusText}`;
            let errorDetails;
            // Check for standard error response format
            if (this.isAPIErrorResponse(data)) {
                errorMessage = data.error;
            }
            // Check for validation error format with details
            else if (data && typeof data === "object" && "detail" in data) {
                const detail = data.detail;
                if (typeof detail === "string") {
                    errorMessage = detail;
                }
                else if (typeof detail === "object" && detail !== null) {
                    // Handle structured error details (from improved validation)
                    if ("error" in detail) {
                        errorMessage = detail.error;
                    }
                    if ("hint" in detail) {
                        errorMessage += ` (${detail.hint})`;
                    }
                    errorDetails = detail;
                }
            }
            // Check for simple error message
            else if (data && typeof data === "object" && "error" in data) {
                errorMessage = data.error;
            }
            // Set errorDetails if not already set
            if (!errorDetails && data && typeof data === "object") {
                errorDetails = data;
            }
            throw new OpenElectricityError(errorMessage, this.isAPIErrorResponse(data) ? data : undefined, response.status, errorDetails);
        }
        return data;
    }
    isAPIErrorResponse(data) {
        return (typeof data === "object" &&
            data !== null &&
            "response_status" in data &&
            data.response_status === "ERROR" &&
            "error" in data &&
            typeof data.error === "string");
    }
    /**
     * Get available metrics and their metadata
     * Useful for discovering what metrics are supported by the API
     */
    async getAvailableMetrics() {
        debug("Getting available metrics");
        const url = `${this.baseUrl}/metrics`;
        const response = await fetch(url, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
            },
        });
        if (!response.ok) {
            throw new Error(`Failed to get metrics: ${response.statusText}`);
        }
        return (await response.json());
    }
    /**
     * Get data from the /data/network endpoint
     * Supports power, energy, emissions and market_value metrics
     *
     * @remarks
     * dateStart and dateEnd should be timezone naive dates in network time.
     * If timezone information is provided, it will be stripped and a warning will be logged.
     */
    async getNetworkData(networkCode, metrics, params = {}) {
        debug("Getting network data", { networkCode, metrics, params });
        const queryParams = new URLSearchParams();
        metrics.forEach((metric) => queryParams.append("metrics", metric));
        if (params.interval)
            queryParams.set("interval", params.interval);
        const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
        const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
        if (dateStart)
            queryParams.set("date_start", dateStart);
        if (dateEnd)
            queryParams.set("date_end", dateEnd);
        if (params.primaryGrouping)
            queryParams.set("primary_grouping", params.primaryGrouping);
        if (params.secondaryGrouping)
            params.secondaryGrouping.forEach((secondaryGrouping) => queryParams.append("secondary_grouping", secondaryGrouping));
        if (params.network_region)
            queryParams.set("network_region", params.network_region);
        if (params.fueltech)
            params.fueltech.forEach((fueltech) => queryParams.append("fueltech", fueltech));
        if (params.fueltech_group)
            params.fueltech_group.forEach((fueltech_group) => queryParams.append("fueltech_group", fueltech_group));
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/data/network/${networkCode}${query}`);
        return {
            response,
            datatable: createDataTable(response.data),
        };
    }
    /**
     * Get data from the /facility endpoint
     * Supports power, energy, emissions and market_value metrics
     *
     * @remarks
     * dateStart and dateEnd should be timezone naive dates in network time.
     * If timezone information is provided, it will be stripped and a warning will be logged.
     */
    async getFacilityData(networkCode, facilityCodes, metrics, params = {}) {
        debug("Getting facility data", {
            networkCode,
            facilityCodes,
            metrics,
            params,
        });
        const queryParams = new URLSearchParams();
        metrics.forEach((metric) => queryParams.append("metrics", metric));
        if (params.interval)
            queryParams.set("interval", params.interval);
        const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
        const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
        if (dateStart)
            queryParams.set("date_start", dateStart);
        if (dateEnd)
            queryParams.set("date_end", dateEnd);
        // Handle single or multiple facility codes
        if (Array.isArray(facilityCodes)) {
            facilityCodes.forEach((code) => queryParams.append("facility_code", code));
        }
        else {
            queryParams.append("facility_code", facilityCodes);
        }
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/data/facilities/${networkCode}${query}`);
        return {
            response,
            datatable: createDataTable(response.data),
        };
    }
    /**
     * Get data from the /market/network endpoint
     * Supports price, demand and demand_energy metrics
     *
     * @remarks
     * dateStart and dateEnd should be timezone naive dates in network time.
     * If timezone information is provided, it will be stripped and a warning will be logged.
     */
    async getMarket(networkCode, metrics, params = {}) {
        debug("Getting market data", { networkCode, metrics, params });
        const queryParams = new URLSearchParams();
        metrics.forEach((metric) => queryParams.append("metrics", metric));
        if (params.interval)
            queryParams.set("interval", params.interval);
        const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
        const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
        if (dateStart)
            queryParams.set("date_start", dateStart);
        if (dateEnd)
            queryParams.set("date_end", dateEnd);
        if (params.primaryGrouping)
            queryParams.set("primary_grouping", params.primaryGrouping);
        if (params.network_region)
            queryParams.set("network_region", params.network_region);
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/market/network/${networkCode}${query}`);
        return {
            response,
            datatable: createDataTable(response.data),
        };
    }
    /**
     * Get facilities and their units from the /facilities endpoint
     * Optionally filter by status, fueltech, network and region
     * Returns empty result if no facilities match the filters (416 status code)
     */
    async getFacilities(params = {}) {
        debug("Getting facilities", { params });
        const queryParams = new URLSearchParams();
        if (params.status_id) {
            params.status_id.forEach((status) => queryParams.append("status_id", status));
        }
        if (params.fueltech_id) {
            params.fueltech_id.forEach((fueltech) => queryParams.append("fueltech_id", fueltech));
        }
        if (params.network_id) {
            if (Array.isArray(params.network_id)) {
                params.network_id.forEach((network) => queryParams.append("network_id", network));
            }
            else {
                queryParams.append("network_id", params.network_id);
            }
        }
        if (params.network_region)
            queryParams.set("network_region", params.network_region);
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/facilities/${query}`);
        // Create a record table with units as rows, including facility information
        const records = response.data.flatMap((facility) => facility.units.map((unit) => ({
            facility_code: facility.code,
            facility_name: facility.name,
            facility_network: facility.network_id,
            facility_region: facility.network_region,
            facility_description: facility.description,
            unit_code: unit.code,
            unit_fueltech: unit.fueltech_id,
            unit_status: unit.status_id,
            unit_capacity: unit.capacity_registered,
            unit_emissions_factor: unit.emissions_factor_co2,
            unit_first_seen: unit.data_first_seen,
            unit_last_seen: unit.data_last_seen,
            unit_dispatch_type: unit.dispatch_type,
        })));
        return {
            response,
            table: new RecordTable(records),
        };
    }
    /**
     * Get pollution data for facilities with NPI tracking
     * Returns time series data for pollutants from the National Pollutant Inventory
     * @param params Parameters for filtering pollution data
     * @returns Promise with time series response containing pollution data
     */
    async getFacilityPollution(params = {}) {
        debug("Getting facility pollution data", { params });
        const queryParams = new URLSearchParams();
        if (params.facility_code) {
            params.facility_code.forEach((code) => queryParams.append("facility_code", code));
        }
        if (params.pollutant_code) {
            params.pollutant_code.forEach((code) => queryParams.append("pollutant_code", code));
        }
        if (params.pollutant_category) {
            params.pollutant_category.forEach((category) => queryParams.append("pollutant_category", category));
        }
        if (params.dateStart) {
            const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
            if (dateStart)
                queryParams.set("date_start", dateStart);
        }
        if (params.dateEnd) {
            const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
            if (dateEnd)
                queryParams.set("date_end", dateEnd);
        }
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/pollution/facilities${query}`);
        // Create data table from the response
        const datatable = response.data.length > 0 ? createDataTable(response.data) : undefined;
        return {
            response,
            datatable,
        };
    }
    /**
     * Get current user information
     */
    async getCurrentUser() {
        debug("Getting current user");
        return this.request("/me");
    }
}

export { DataTable, NoDataFound, OpenElectricityClient, OpenElectricityError, OpenElectricityClient as default, getLastCompleteInterval, getNetworkTimezone, getNetworkTimezoneOffset, isAware, makeAware, stripTimezone };
//# sourceMappingURL=index.js.map
