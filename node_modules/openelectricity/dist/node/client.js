"use strict";
/**
 * OpenElectricity API Client
 *
 * A TypeScript client for the OpenElectricity API v4.
 * Provides access to electricity network data and metrics.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenElectricityClient = exports.NoDataFound = exports.OpenElectricityError = void 0;
/// <reference lib="dom" />
const datatable_1 = require("./datatable");
const datetime_1 = require("./datetime");
const recordtable_1 = require("./recordtable");
const utils_1 = require("./utils");
class OpenElectricityError extends Error {
    constructor(message, response, statusCode, details) {
        super(message);
        this.response = response;
        this.statusCode = statusCode;
        this.details = details;
        this.name = "OpenElectricityError";
    }
}
exports.OpenElectricityError = OpenElectricityError;
class NoDataFound extends Error {
    constructor(message) {
        super(message);
        this.name = "NoDataFound";
    }
}
exports.NoDataFound = NoDataFound;
/**
 * Convert a date string to timezone naive format and warn if timezone information is present
 *
 * @param date The date string to process
 * @param paramName The name of the parameter (for warning message)
 * @returns The timezone naive date string
 */
function toTimezoneNaiveDate(date, paramName) {
    if (!date)
        return undefined;
    if ((0, datetime_1.isAware)(date)) {
        (0, utils_1.debug)(`Warning: ${paramName} contains timezone information which will be stripped. The API requires timezone naive dates in network time.`, {
            original: date,
            stripped: (0, datetime_1.stripTimezone)(date),
        });
        return (0, datetime_1.stripTimezone)(date);
    }
    return date;
}
class OpenElectricityClient {
    // private static apiVersion: string = "v4"
    constructor(options = {}) {
        // eslint-disable-next-line no-undef
        this.apiKey = options.apiKey || process?.env?.OPENELECTRICITY_API_KEY || "";
        if (!this.apiKey) {
            throw new Error("API key is required");
        }
        // eslint-disable-next-line no-undef
        this.baseUrl =
            options.baseUrl ||
                process?.env?.OPENELECTRICITY_API_URL ||
                "https://api.openelectricity.org.au/v4";
        (0, utils_1.debug)("Initializing client", { baseUrl: this.baseUrl });
    }
    async request(path, options = {}) {
        const url = `${this.baseUrl}${path}`;
        const headers = {
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
            ...options.headers,
        };
        (0, utils_1.debug)("Making request", {
            url,
            method: options.method || "GET",
            headers: { ...headers, Authorization: "***" },
        });
        const startTime = Date.now();
        // eslint-disable-next-line no-undef
        const response = await fetch(url, {
            ...options,
            headers,
        });
        const duration = Date.now() - startTime;
        (0, utils_1.debug)(`Request completed in ${duration}ms`, {
            status: response.status,
            statusText: response.statusText,
        });
        // Special handling for 416 (no results)
        if (response.status === 416) {
            throw new NoDataFound("No data found for the requested parameters");
        }
        // Special handling for 403 (permission denied)
        if (response.status === 403) {
            (0, utils_1.debug)("Permission denied", {
                status: response.status,
                statusText: response.statusText,
            });
            throw new Error("Permission denied. Check API key or your access level");
        }
        // Try to parse JSON response, handle cases where response is not valid JSON
        let data;
        try {
            data = await response.json();
        }
        catch (jsonError) {
            // If we can't parse JSON and it's an error response, provide a meaningful error
            if (!response.ok) {
                (0, utils_1.debug)("Failed to parse JSON response", {
                    status: response.status,
                    statusText: response.statusText,
                    error: jsonError,
                });
                // For 500 errors, provide a more specific message
                if (response.status === 500) {
                    throw new OpenElectricityError("Internal server error - the requested data may not be available for this date range", undefined, response.status, { parseError: "Response was not valid JSON" });
                }
                throw new OpenElectricityError(`API request failed: ${response.statusText} (unable to parse response)`, undefined, response.status, { parseError: "Response was not valid JSON" });
            }
            throw jsonError;
        }
        // Handle API error responses
        if (!response.ok) {
            (0, utils_1.debug)("Request failed", {
                status: response.status,
                statusText: response.statusText,
                data,
            });
            // Parse different error response formats
            let errorMessage = `API request failed: ${response.statusText}`;
            let errorDetails;
            // Check for standard error response format
            if (this.isAPIErrorResponse(data)) {
                errorMessage = data.error;
            }
            // Check for validation error format with details
            else if (data && typeof data === "object" && "detail" in data) {
                const detail = data.detail;
                if (typeof detail === "string") {
                    errorMessage = detail;
                }
                else if (typeof detail === "object" && detail !== null) {
                    // Handle structured error details (from improved validation)
                    if ("error" in detail) {
                        errorMessage = detail.error;
                    }
                    if ("hint" in detail) {
                        errorMessage += ` (${detail.hint})`;
                    }
                    errorDetails = detail;
                }
            }
            // Check for simple error message
            else if (data && typeof data === "object" && "error" in data) {
                errorMessage = data.error;
            }
            // Set errorDetails if not already set
            if (!errorDetails && data && typeof data === "object") {
                errorDetails = data;
            }
            throw new OpenElectricityError(errorMessage, this.isAPIErrorResponse(data) ? data : undefined, response.status, errorDetails);
        }
        return data;
    }
    isAPIErrorResponse(data) {
        return (typeof data === "object" &&
            data !== null &&
            "response_status" in data &&
            data.response_status === "ERROR" &&
            "error" in data &&
            typeof data.error === "string");
    }
    /**
     * Get available metrics and their metadata
     * Useful for discovering what metrics are supported by the API
     */
    async getAvailableMetrics() {
        (0, utils_1.debug)("Getting available metrics");
        const url = `${this.baseUrl}/metrics`;
        const response = await fetch(url, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
            },
        });
        if (!response.ok) {
            throw new Error(`Failed to get metrics: ${response.statusText}`);
        }
        return (await response.json());
    }
    /**
     * Get data from the /data/network endpoint
     * Supports power, energy, emissions and market_value metrics
     *
     * @remarks
     * dateStart and dateEnd should be timezone naive dates in network time.
     * If timezone information is provided, it will be stripped and a warning will be logged.
     */
    async getNetworkData(networkCode, metrics, params = {}) {
        (0, utils_1.debug)("Getting network data", { networkCode, metrics, params });
        const queryParams = new URLSearchParams();
        metrics.forEach((metric) => queryParams.append("metrics", metric));
        if (params.interval)
            queryParams.set("interval", params.interval);
        const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
        const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
        if (dateStart)
            queryParams.set("date_start", dateStart);
        if (dateEnd)
            queryParams.set("date_end", dateEnd);
        if (params.primaryGrouping)
            queryParams.set("primary_grouping", params.primaryGrouping);
        if (params.secondaryGrouping)
            params.secondaryGrouping.forEach((secondaryGrouping) => queryParams.append("secondary_grouping", secondaryGrouping));
        if (params.network_region)
            queryParams.set("network_region", params.network_region);
        if (params.fueltech)
            params.fueltech.forEach((fueltech) => queryParams.append("fueltech", fueltech));
        if (params.fueltech_group)
            params.fueltech_group.forEach((fueltech_group) => queryParams.append("fueltech_group", fueltech_group));
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/data/network/${networkCode}${query}`);
        return {
            response,
            datatable: (0, datatable_1.createDataTable)(response.data),
        };
    }
    /**
     * Get data from the /facility endpoint
     * Supports power, energy, emissions and market_value metrics
     *
     * @remarks
     * dateStart and dateEnd should be timezone naive dates in network time.
     * If timezone information is provided, it will be stripped and a warning will be logged.
     */
    async getFacilityData(networkCode, facilityCodes, metrics, params = {}) {
        (0, utils_1.debug)("Getting facility data", {
            networkCode,
            facilityCodes,
            metrics,
            params,
        });
        const queryParams = new URLSearchParams();
        metrics.forEach((metric) => queryParams.append("metrics", metric));
        if (params.interval)
            queryParams.set("interval", params.interval);
        const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
        const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
        if (dateStart)
            queryParams.set("date_start", dateStart);
        if (dateEnd)
            queryParams.set("date_end", dateEnd);
        // Handle single or multiple facility codes
        if (Array.isArray(facilityCodes)) {
            facilityCodes.forEach((code) => queryParams.append("facility_code", code));
        }
        else {
            queryParams.append("facility_code", facilityCodes);
        }
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/data/facilities/${networkCode}${query}`);
        return {
            response,
            datatable: (0, datatable_1.createDataTable)(response.data),
        };
    }
    /**
     * Get data from the /market/network endpoint
     * Supports price, demand and demand_energy metrics
     *
     * @remarks
     * dateStart and dateEnd should be timezone naive dates in network time.
     * If timezone information is provided, it will be stripped and a warning will be logged.
     */
    async getMarket(networkCode, metrics, params = {}) {
        (0, utils_1.debug)("Getting market data", { networkCode, metrics, params });
        const queryParams = new URLSearchParams();
        metrics.forEach((metric) => queryParams.append("metrics", metric));
        if (params.interval)
            queryParams.set("interval", params.interval);
        const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
        const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
        if (dateStart)
            queryParams.set("date_start", dateStart);
        if (dateEnd)
            queryParams.set("date_end", dateEnd);
        if (params.primaryGrouping)
            queryParams.set("primary_grouping", params.primaryGrouping);
        if (params.network_region)
            queryParams.set("network_region", params.network_region);
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/market/network/${networkCode}${query}`);
        return {
            response,
            datatable: (0, datatable_1.createDataTable)(response.data),
        };
    }
    /**
     * Get facilities and their units from the /facilities endpoint
     * Optionally filter by status, fueltech, network and region
     * Returns empty result if no facilities match the filters (416 status code)
     */
    async getFacilities(params = {}) {
        (0, utils_1.debug)("Getting facilities", { params });
        const queryParams = new URLSearchParams();
        if (params.status_id) {
            params.status_id.forEach((status) => queryParams.append("status_id", status));
        }
        if (params.fueltech_id) {
            params.fueltech_id.forEach((fueltech) => queryParams.append("fueltech_id", fueltech));
        }
        if (params.network_id) {
            if (Array.isArray(params.network_id)) {
                params.network_id.forEach((network) => queryParams.append("network_id", network));
            }
            else {
                queryParams.append("network_id", params.network_id);
            }
        }
        if (params.network_region)
            queryParams.set("network_region", params.network_region);
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/facilities/${query}`);
        // Create a record table with units as rows, including facility information
        const records = response.data.flatMap((facility) => facility.units.map((unit) => ({
            facility_code: facility.code,
            facility_name: facility.name,
            facility_network: facility.network_id,
            facility_region: facility.network_region,
            facility_description: facility.description,
            unit_code: unit.code,
            unit_fueltech: unit.fueltech_id,
            unit_status: unit.status_id,
            unit_capacity: unit.capacity_registered,
            unit_emissions_factor: unit.emissions_factor_co2,
            unit_first_seen: unit.data_first_seen,
            unit_last_seen: unit.data_last_seen,
            unit_dispatch_type: unit.dispatch_type,
        })));
        return {
            response,
            table: new recordtable_1.RecordTable(records),
        };
    }
    /**
     * Get pollution data for facilities with NPI tracking
     * Returns time series data for pollutants from the National Pollutant Inventory
     * @param params Parameters for filtering pollution data
     * @returns Promise with time series response containing pollution data
     */
    async getFacilityPollution(params = {}) {
        (0, utils_1.debug)("Getting facility pollution data", { params });
        const queryParams = new URLSearchParams();
        if (params.facility_code) {
            params.facility_code.forEach((code) => queryParams.append("facility_code", code));
        }
        if (params.pollutant_code) {
            params.pollutant_code.forEach((code) => queryParams.append("pollutant_code", code));
        }
        if (params.pollutant_category) {
            params.pollutant_category.forEach((category) => queryParams.append("pollutant_category", category));
        }
        if (params.dateStart) {
            const dateStart = toTimezoneNaiveDate(params.dateStart, "dateStart");
            if (dateStart)
                queryParams.set("date_start", dateStart);
        }
        if (params.dateEnd) {
            const dateEnd = toTimezoneNaiveDate(params.dateEnd, "dateEnd");
            if (dateEnd)
                queryParams.set("date_end", dateEnd);
        }
        const query = queryParams.toString() ? `?${queryParams.toString()}` : "";
        const response = await this.request(`/pollution/facilities${query}`);
        // Create data table from the response
        const datatable = response.data.length > 0 ? (0, datatable_1.createDataTable)(response.data) : undefined;
        return {
            response,
            datatable,
        };
    }
    /**
     * Get current user information
     */
    async getCurrentUser() {
        (0, utils_1.debug)("Getting current user");
        return this.request("/me");
    }
}
exports.OpenElectricityClient = OpenElectricityClient;
//# sourceMappingURL=client.js.map